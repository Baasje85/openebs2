 <div id="swimlanes">

    </div>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script type="text/javascript">
d3.json("{% url "report_details" %}", function(data) {
function display () {

	var rects, labels
	  , minExtent = d3.time.day(brush.extent()[0])
	  , maxExtent = d3.time.day(brush.extent()[1])
	  , visItems = items.filter(function (d) { return d.start < maxExtent && d.end > minExtent});

	mini.select('.brush').call(brush.extent([minExtent, maxExtent]));


	x1.domain([minExtent, maxExtent]);

	if ((maxExtent - minExtent) > 1468800000) {
		x1DateAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%a %d'))
		x1MonthAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%b - Week %W'))
	}
	else if ((maxExtent - minExtent) > 172800000) {
		x1DateAxis.ticks(d3.time.days, 1).tickFormat(d3.time.format('%a %d'))
		x1MonthAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%b - Week %W'))
	}
	else if ((maxExtent - minExtent) > 86400000) {
		x1DateAxis.ticks(d3.time.hours, 4).tickFormat(d3.time.format('%I %p'))
		x1MonthAxis.ticks(d3.time.days, 1).tickFormat(d3.time.format('%b %e'))
	}
	else {
		x1DateAxis.ticks(d3.time.hours, 1).tickFormat(d3.time.format('%H:%M'))
	}


	// update the item rects
	rects = itemRects.selectAll('rect')
		.data(visItems, function (d) { return d.id; })
		.attr('x', function(d) { return x1(d.start); })
		.attr('width', function(d) { return x1(d.end) - x1(d.start); });


	rects.exit().remove();

	// update the item labels
	labels = itemRects.selectAll('text')
		.data(visItems, function (d) { return d.id; })
		.attr('x', function(d) { return x1(Math.max(d.start, minExtent)) + 2; });

	labels.enter().append('text')
		.text(function (d) { return 'Item\n\n\n\n Id: ' + d.id; })
		.attr('x', function(d) { return x1(Math.max(d.start, minExtent)) + 2; })
		.attr('y', function(d) { return y1(d.lane) + .4 * y1(1) + 0.5; })
		.attr('text-anchor', 'start')
		.attr('class', 'itemLabel');

	labels.exit().remove();
}

function moveBrush () {
	var origin = d3.mouse(this)
	  , point = x.invert(origin[0])
	  , halfExtent = (brush.extent()[1].getTime() - brush.extent()[0].getTime()) / 2
	  , start = new Date(point.getTime() - halfExtent)
	  , end = new Date(point.getTime() + halfExtent);

	brush.extent([start,end]);
	display();
}

// generates a single path for each item class in the mini display
// ugly - but draws mini 2x faster than append lines or line generator
// is there a better way to do a bunch of lines as a single path with d3?
function getPaths(items) {
	var paths = {}, d, offset = .5 * y2(1) + 0.5, result = [];
	for (var i = 0; i < items.length; i++) {
		d = items[i];
		if (!paths[d.class]) paths[d.class] = '';
		paths[d.class] += ['M',x(d.start),(y2(d.lane) + offset),'H',x(d.end)].join(' ');
	}

	for (var className in paths) {
		result.push({class: className, path: paths[className]});
	}

	return result;
}

var addToLane = function (chart, item) {
    var name = item.lane;

    if (!chart.lanes[name])
        chart.lanes[name] = [];

    var lane = chart.lanes[name];

    var sublane = 0;
    while(isOverlapping(item, lane[sublane]))
        sublane++;

    if (!lane[sublane]) {
        lane[sublane] = [];
        }

    lane[sublane].push(item);
};

var isOverlapping = function(item, lane) {
        if (lane) {
        for (var i = 0; i < lane.length; i++) {
            var t = lane[i];
            if (item.start < t.end && item.end > t.start) {
                return true;
            }
        }
        }
    return false;
};

var parseData = function (data) {
    var i = 0, length = data.length, node;
    chart = { lanes: {} };

    for (i; i < length; i++) {
    if (data[i] !== null) {
        var item = data[i];

            addToLane(chart, item);
        }
    }

    return collapseLanes(chart);
};

var collapseLanes = function (chart) {
        var lanes = [], items = [], laneId = 0;
        var now = new Date();

        for (var laneName in chart.lanes) {
                var lane = chart.lanes[laneName];

                for (var i = 0; i < lane.length; i++) {
                        var subLane = lane[i];

                        lanes.push({
                                id: laneId,
                                label: i === 0 ? laneName : ''
                        });

                        for (var j = 0; j < subLane.length; j++) {
                                var item = subLane[j];

                                items.push({
                                        id: item.id,
                                        lane: laneId,
                                        start: item.start,
                                        end: item.end,
                                        class: item.link ? 'past' : 'missed',
                                        desc: item.desc
                                });
                        }

                        laneId++;
                }
        }
            return {lanes: lanes, items: items};
    }

	// LinePlanningNumber,JourneyNumber,ReinforcementNumber,Init,End
	var now = new Date();
	var dt = now.getTime();
	var id = 0;
	var data = parseData(data.details.map(function(d) {
		id += 1;
		var workItem = {
			id: id,
			name: d["journeynumber"],
			lane: d["lineplanningnumber"]+" "+((d["direction"] == 1) ? "heen" : "terug"),
			start: new Date(dt + (d["departuretime"] * 1000)),
			end: new Date(dt + ((d["departuretime"]+ d["duration"]) * 1000 )),
			link: d["id"] > 0,
			desc: ""
		};

		return workItem;
	}));

	var lanes = data.lanes;
	var items = data.items;
	var margin = {top: 20, right: 15, bottom: 15, left: 60}
	  , width = 960 - margin.left - margin.right
	  , height = 500 - margin.top - margin.bottom
	  , miniHeight = lanes.length * 12 + 50
	  , mainHeight = 0;

	if (height < miniHeight) {
		height = miniHeight + margin.bottom + margin.top;
	}

	var x = d3.time.scale()
		.domain([now, new Date(now.getTime() + (60*60*30*1000))])
		.range([0, width]);
	var x1 = d3.time.scale().range([0, width]);

	var ext = d3.extent(lanes, function(d) { return d.id; });
	var y1 = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, mainHeight]);
	var y2 = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, miniHeight]);

	var chart = d3.select('#swimlanes')
		.append('svg:svg')
		.attr('width', width + margin.right + margin.left)
		.attr('height', height + margin.top + margin.bottom)
		.attr('class', 'chart');

	chart.append('defs').append('clipPath')
		.attr('id', 'clip')
		.append('rect')
			.attr('width', width)
			.attr('height', mainHeight);

	var mini = chart.append('g')
		.attr('transform', 'translate(' + margin.left + ',' + (mainHeight + 60) + ')')
		.attr('width', width)
		.attr('height', miniHeight)
		.attr('class', 'mini');

	// draw the lanes for the mini chart
	mini.append('g').selectAll('.laneLines')
		.data(lanes)
		.enter().append('line')
		.attr('x1', 0)
		.attr('y1', function(d) { return d3.round(y2(d.id)) + 0.5; })
		.attr('x2', width)
		.attr('y2', function(d) { return d3.round(y2(d.id)) + 0.5; })
		.attr('stroke', function(d) { return d.label === '' ? 'white' : 'lightgray' });

	mini.append('g').selectAll('.laneText')
		.data(lanes)
		.enter().append('text')
		.text(function(d) { return d.label; })
		.attr('x', -10)
		.attr('y', function(d) { return y2(d.id + .5); })
		.attr('dy', '0.5ex')
		.attr('text-anchor', 'end')
		.attr('class', 'laneText');

	// draw the x axis
	var xDateAxis = d3.svg.axis()
		.scale(x)
		.orient('bottom')
		.ticks(d3.time.mondays, (x.domain()[1] - x.domain()[0]) > 15552e6 ? 2 : 1)
		.tickFormat(d3.time.format('%d'))
		.tickSize(6, 0, 0);

	var x1DateAxis = d3.svg.axis()
		.scale(x1)
		.orient('bottom')
		.ticks(d3.time.days, 1)
		.tickFormat(d3.time.format('%a %d'))
		.tickSize(6, 0, 0);

	var xMonthAxis = d3.svg.axis()
		.scale(x)
		.orient('top')
		.ticks(d3.time.months, 1)
		.tickFormat(d3.time.format('%b %Y'))
		.tickSize(15, 0, 0);

	var x1MonthAxis = d3.svg.axis()
		.scale(x1)
		.orient('top')
		.ticks(d3.time.mondays, 1)
		.tickFormat(d3.time.format('%b - Week %W'))
		.tickSize(15, 0, 0);

	mini.append('g')
		.attr('transform', 'translate(0,' + miniHeight + ')')
		.attr('class', 'axis date')
		.call(xDateAxis);

	mini.append('g')
		.attr('transform', 'translate(0,0.5)')
		.attr('class', 'axis month')
		.call(xMonthAxis)
		.selectAll('text')
			.attr('dx', 5)
			.attr('dy', 12);

	mini.append('g').selectAll('miniItems')
		.data(getPaths(items))
		.enter().append('path')
		.attr('class', function(d) { return 'miniItem ' + d.class; })
		.attr('d', function(d) { return d.path; });

	// invisible hit area to move around the selection window
	mini.append('rect')
		.attr('pointer-events', 'painted')
		.attr('width', width)
		.attr('height', miniHeight)
		.attr('visibility', 'hidden')
		.on('mouseup', moveBrush);

	mini.selectAll('rect.background').remove();
	display();
});
		</script>
{% endblock %}

{% block extra_css %}
<style>
.chart {
	shape-rendering: crispEdges;
}

.mini text {
	font: 9px sans-serif;
}

.main text {
	font: 12px sans-serif;
}

.month text {
	text-anchor: start;
}

.todayLine {
	stroke: blue;
	stroke-width: 1.5;
}

.axis line, .axis path {
	stroke: black;
}

.miniItem {
	stroke-width: 6;
}

.future {
	stroke: gray;
	fill: #ddd;
}

.past {
	stroke: green;
	fill: lightgreen;
}

.missed {
	stroke: red;
	fill: lightred;
}

.brush .extent {
	stroke: gray;
	fill: blue;
	fill-opacity: .165;
}
</style>